<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TrussForge — Parametric Truss Modeler</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Barlow+Condensed:wght@300;400;600;700;900&display=swap');

  :root {
    --bg: #0a0c0f;
    --panel: #0f1317;
    --panel2: #141a20;
    --border: #1e2832;
    --accent: #00e5ff;
    --accent2: #ff6b35;
    --accent3: #7fff6e;
    --text: #c8d8e8;
    --muted: #4a5a6a;
    --node: #00e5ff;
    --member: #ff6b35;
    --support: #7fff6e;
    --load: #ff4444;
    --w: 320px;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Barlow Condensed', sans-serif;
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 20px;
    border-bottom: 1px solid var(--border);
    background: var(--panel);
    flex-shrink: 0;
    z-index: 10;
  }

  .logo {
    font-family: 'Share Tech Mono', monospace;
    font-size: 1.4rem;
    letter-spacing: 0.08em;
    color: var(--accent);
  }
  .logo span { color: var(--accent2); }

  .header-badges {
    display: flex;
    gap: 12px;
    font-size: 0.75rem;
    letter-spacing: 0.1em;
    color: var(--muted);
    text-transform: uppercase;
  }
  .badge {
    padding: 3px 10px;
    border: 1px solid var(--border);
    border-radius: 2px;
  }
  .badge.active { color: var(--accent3); border-color: var(--accent3); }

  .workspace {
    display: flex;
    flex: 1;
    overflow: hidden;
  }

  /* PANEL */
  .panel {
    width: var(--w);
    background: var(--panel);
    border-right: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    flex-shrink: 0;
  }

  .panel::-webkit-scrollbar { width: 4px; }
  .panel::-webkit-scrollbar-track { background: transparent; }
  .panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .section {
    border-bottom: 1px solid var(--border);
    padding: 14px 16px;
  }

  .section-title {
    font-size: 0.65rem;
    letter-spacing: 0.2em;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .section-title::after {
    content: '';
    flex: 1;
    height: 1px;
    background: var(--border);
  }

  .param-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    margin-bottom: 8px;
  }
  .param-row.full { grid-template-columns: 1fr; }

  .param-group label {
    display: block;
    font-size: 0.65rem;
    letter-spacing: 0.12em;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 4px;
  }

  .param-group input[type="range"] {
    width: 100%;
    -webkit-appearance: none;
    height: 3px;
    background: var(--border);
    border-radius: 2px;
    outline: none;
    cursor: pointer;
  }
  .param-group input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    transition: transform 0.15s;
  }
  .param-group input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.4); }

  .param-group input[type="number"],
  .param-group select {
    width: 100%;
    background: var(--panel2);
    border: 1px solid var(--border);
    color: var(--text);
    padding: 5px 8px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.8rem;
    border-radius: 2px;
    outline: none;
    transition: border-color 0.2s;
  }
  .param-group input[type="number"]:focus,
  .param-group select:focus { border-color: var(--accent); }

  .val-display {
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.9rem;
    color: var(--accent);
    text-align: right;
    margin-bottom: 2px;
  }

  .btn {
    padding: 8px 14px;
    border: none;
    border-radius: 2px;
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.85rem;
    font-weight: 600;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    cursor: pointer;
    transition: all 0.15s;
  }
  .btn-primary {
    background: var(--accent);
    color: #000;
    width: 100%;
  }
  .btn-primary:hover { background: #fff; }
  .btn-secondary {
    background: transparent;
    color: var(--accent);
    border: 1px solid var(--accent);
    flex: 1;
  }
  .btn-secondary:hover { background: var(--accent); color: #000; }
  .btn-danger {
    background: transparent;
    color: var(--accent2);
    border: 1px solid var(--accent2);
    flex: 1;
  }
  .btn-danger:hover { background: var(--accent2); color: #000; }

  .btn-row { display: flex; gap: 8px; }

  .truss-type-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
    margin-bottom: 4px;
  }
  .type-btn {
    padding: 8px 4px;
    background: var(--panel2);
    border: 1px solid var(--border);
    color: var(--muted);
    font-family: 'Barlow Condensed', sans-serif;
    font-size: 0.75rem;
    font-weight: 600;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    cursor: pointer;
    border-radius: 2px;
    text-align: center;
    transition: all 0.15s;
  }
  .type-btn:hover, .type-btn.active {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(0,229,255,0.05);
  }

  /* STATS */
  .stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }
  .stat-box {
    background: var(--panel2);
    border: 1px solid var(--border);
    padding: 8px 10px;
    border-radius: 2px;
  }
  .stat-box .label {
    font-size: 0.6rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: var(--muted);
    margin-bottom: 2px;
  }
  .stat-box .value {
    font-family: 'Share Tech Mono', monospace;
    font-size: 1rem;
    color: var(--accent3);
  }

  /* LEGEND */
  .legend { display: flex; flex-wrap: wrap; gap: 10px; }
  .legend-item { display: flex; align-items: center; gap: 6px; font-size: 0.75rem; color: var(--muted); }
  .legend-dot { width: 10px; height: 10px; border-radius: 50%; }
  .legend-line { width: 20px; height: 3px; border-radius: 1px; }

  /* CANVAS */
  .viewport {
    flex: 1;
    position: relative;
    background: var(--bg);
    overflow: hidden;
  }

  #canvas { display: block; width: 100%; height: 100%; }

  .viewport-overlay {
    position: absolute;
    top: 14px; right: 14px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    font-size: 0.65rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
    color: var(--muted);
    pointer-events: none;
  }

  .view-hint {
    background: rgba(10,12,15,0.8);
    border: 1px solid var(--border);
    padding: 4px 10px;
    border-radius: 2px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.6rem;
  }

  .axes-indicator {
    position: absolute;
    bottom: 14px; right: 14px;
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.65rem;
    pointer-events: none;
  }

  .force-info {
    position: absolute;
    bottom: 14px; left: 14px;
    background: rgba(10,12,15,0.85);
    border: 1px solid var(--border);
    border-left: 2px solid var(--accent2);
    padding: 8px 14px;
    font-size: 0.7rem;
    letter-spacing: 0.05em;
    max-width: 280px;
  }
  .force-info .fi-title {
    font-family: 'Share Tech Mono', monospace;
    color: var(--accent2);
    font-size: 0.65rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    margin-bottom: 6px;
  }
  .fi-row { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 2px; }
  .fi-key { color: var(--muted); }
  .fi-val { font-family: 'Share Tech Mono', monospace; color: var(--text); }

  .grid-toggle {
    position: absolute;
    top: 14px; left: 14px;
    display: flex; gap: 6px;
  }
  .ctrl-btn {
    background: rgba(10,12,15,0.85);
    border: 1px solid var(--border);
    color: var(--muted);
    font-family: 'Share Tech Mono', monospace;
    font-size: 0.65rem;
    padding: 4px 10px;
    cursor: pointer;
    border-radius: 2px;
    letter-spacing: 0.08em;
    transition: all 0.15s;
  }
  .ctrl-btn:hover, .ctrl-btn.on { color: var(--accent); border-color: var(--accent); }

  .scanline {
    position: absolute; inset: 0;
    background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px);
    pointer-events: none;
    z-index: 1;
  }

  select option { background: #141a20; }

  /* LOAD color scheme select */
  .color-row { display: flex; gap: 6px; margin-top: 6px; }
  .color-swatch {
    width: 24px; height: 24px; border-radius: 2px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: border-color 0.15s;
    flex-shrink: 0;
  }
  .color-swatch.sel { border-color: #fff; }

</style>
</head>
<body>

<header>
  <div class="logo">Truss<span>Forge</span> <span style="font-size:0.7rem;color:var(--muted)">// parametric modeler</span></div>
  <div class="header-badges">
    <div class="badge active">3D View</div>
    <div class="badge" id="hdr-nodes">0 nodes</div>
    <div class="badge" id="hdr-members">0 members</div>
    <div class="badge" id="hdr-dof">Isostatic</div>
  </div>
</header>

<div class="workspace">

  <!-- LEFT PANEL -->
  <div class="panel">

    <!-- TRUSS TYPE -->
    <div class="section">
      <div class="section-title">Truss Type</div>
      <div class="truss-type-grid">
        <button class="type-btn active" onclick="setType('pratt')">Pratt</button>
        <button class="type-btn" onclick="setType('howe')">Howe</button>
        <button class="type-btn" onclick="setType('warren')">Warren</button>
        <button class="type-btn" onclick="setType('k-truss')">K-Truss</button>
        <button class="type-btn" onclick="setType('vierendeel')">Viernedeel</button>
        <button class="type-btn" onclick="setType('arch')">Arch</button>
      </div>
    </div>

    <!-- GEOMETRY -->
    <div class="section">
      <div class="section-title">Geometry</div>

      <div class="param-row">
        <div class="param-group">
          <label>Span (m)</label>
          <div class="val-display" id="v-span">24</div>
          <input type="range" id="span" min="4" max="60" value="24" step="2" oninput="syncVal('span','v-span','');rebuild()">
        </div>
        <div class="param-group">
          <label>Height (m)</label>
          <div class="val-display" id="v-height">4</div>
          <input type="range" id="height" min="1" max="16" value="4" step="0.5" oninput="syncVal('height','v-height','');rebuild()">
        </div>
      </div>

      <div class="param-row">
        <div class="param-group">
          <label>Panels</label>
          <div class="val-display" id="v-panels">6</div>
          <input type="range" id="panels" min="2" max="16" value="6" step="2" oninput="syncVal('panels','v-panels','');rebuild()">
        </div>
        <div class="param-group">
          <label>Width (m)</label>
          <div class="val-display" id="v-width">3</div>
          <input type="range" id="width" min="0" max="12" value="3" step="1" oninput="syncVal('width','v-width','');rebuild()">
        </div>
      </div>

      <div class="param-row">
        <div class="param-group">
          <label>Arch Sag (m)</label>
          <div class="val-display" id="v-sag">0</div>
          <input type="range" id="sag" min="0" max="10" value="0" step="0.5" oninput="syncVal('sag','v-sag','');rebuild()">
        </div>
        <div class="param-group">
          <label>Depth factor</label>
          <div class="val-display" id="v-depth">1.0</div>
          <input type="range" id="depth" min="0.5" max="3" value="1" step="0.1" oninput="syncVal('depth','v-depth','');rebuild()">
        </div>
      </div>
    </div>

    <!-- LOADING -->
    <div class="section">
      <div class="section-title">Loading</div>
      <div class="param-row">
        <div class="param-group">
          <label>UDL (kN/m)</label>
          <div class="val-display" id="v-udl">10</div>
          <input type="range" id="udl" min="0" max="100" value="10" step="5" oninput="syncVal('udl','v-udl','');rebuild()">
        </div>
        <div class="param-group">
          <label>Point load (kN)</label>
          <div class="val-display" id="v-pl">0</div>
          <input type="range" id="pl" min="0" max="500" value="0" step="10" oninput="syncVal('pl','v-pl','');rebuild()">
        </div>
      </div>
      <div class="param-row">
        <div class="param-group">
          <label>Load at panel #</label>
          <div class="val-display" id="v-ploc">3</div>
          <input type="range" id="ploc" min="1" max="15" value="3" step="1" oninput="syncVal('ploc','v-ploc','');rebuild()">
        </div>
        <div class="param-group">
          <label>Self-weight (kN/m)</label>
          <div class="val-display" id="v-sw">2</div>
          <input type="range" id="sw" min="0" max="20" value="2" step="1" oninput="syncVal('sw','v-sw','');rebuild()">
        </div>
      </div>
    </div>

    <!-- DISPLAY -->
    <div class="section">
      <div class="section-title">Display</div>
      <div class="param-row">
        <div class="param-group">
          <label>Color scheme</label>
          <select id="colorScheme" onchange="rebuild()">
            <option value="stress">Axial stress</option>
            <option value="type">Member type</option>
            <option value="length">Member length</option>
            <option value="mono">Monochrome</option>
          </select>
        </div>
        <div class="param-group">
          <label>Member Ø (mm)</label>
          <div class="val-display" id="v-memberR">30</div>
          <input type="range" id="memberR" min="5" max="80" value="30" step="5" oninput="syncVal('memberR','v-memberR','');rebuild()">
        </div>
      </div>
    </div>

    <!-- STATS -->
    <div class="section">
      <div class="section-title">Analysis</div>
      <div class="stats-grid">
        <div class="stat-box">
          <div class="label">Nodes</div>
          <div class="value" id="stat-nodes">0</div>
        </div>
        <div class="stat-box">
          <div class="label">Members</div>
          <div class="value" id="stat-members">0</div>
        </div>
        <div class="stat-box">
          <div class="label">Max Tension</div>
          <div class="value" id="stat-tension" style="color:#ff4444">— kN</div>
        </div>
        <div class="stat-box">
          <div class="label">Max Compress</div>
          <div class="value" id="stat-compress" style="color:#00e5ff">— kN</div>
        </div>
        <div class="stat-box">
          <div class="label">Reactions ΣV</div>
          <div class="value" id="stat-reactions">— kN</div>
        </div>
        <div class="stat-box">
          <div class="label">Slenderness</div>
          <div class="value" id="stat-slender">—</div>
        </div>
      </div>
    </div>

    <!-- LEGEND -->
    <div class="section">
      <div class="section-title">Legend</div>
      <div class="legend">
        <div class="legend-item"><div class="legend-dot" style="background:var(--node)"></div>Node</div>
        <div class="legend-item"><div class="legend-line" style="background:var(--accent2)"></div>Compression</div>
        <div class="legend-item"><div class="legend-line" style="background:var(--load)"></div>Tension</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--support)"></div>Support</div>
        <div class="legend-item"><div class="legend-dot" style="background:var(--load)"></div>Load</div>
      </div>
    </div>

    <!-- ACTIONS -->
    <div class="section">
      <div class="section-title">Actions</div>
      <div class="btn-row" style="margin-bottom:8px">
        <button class="btn btn-secondary" onclick="resetCamera()">Reset View</button>
        <button class="btn btn-danger" onclick="randomize()">Randomize</button>
      </div>
      <button class="btn btn-primary" onclick="exportData()">Export JSON</button>
    </div>

  </div>

  <!-- VIEWPORT -->
  <div class="viewport">
    <div class="scanline"></div>
    <canvas id="canvas"></canvas>

    <div class="grid-toggle">
      <button class="ctrl-btn on" id="btn-grid" onclick="toggleGrid()">Grid</button>
      <button class="ctrl-btn on" id="btn-labels" onclick="toggleLabels()">Labels</button>
      <button class="ctrl-btn on" id="btn-forces" onclick="toggleForces()">Forces</button>
      <button class="ctrl-btn" id="btn-anim" onclick="toggleAnim()">Animate</button>
    </div>

    <div class="viewport-overlay">
      <div class="view-hint">LMB — Rotate</div>
      <div class="view-hint">RMB / Scroll — Zoom</div>
      <div class="view-hint">MMB — Pan</div>
    </div>

    <div class="force-info" id="force-info">
      <div class="fi-title">⬡ Structural Summary</div>
      <div class="fi-row"><span class="fi-key">Support type</span><span class="fi-val">Pin + Roller</span></div>
      <div class="fi-row"><span class="fi-key">Stability</span><span class="fi-val" id="fi-stab">Stable</span></div>
      <div class="fi-row"><span class="fi-key">Max deflection</span><span class="fi-val" id="fi-defl">~L/300</span></div>
      <div class="fi-row"><span class="fi-key">Total load</span><span class="fi-val" id="fi-load">— kN</span></div>
    </div>
  </div>

</div>

<script>
// ─── GLOBALS ────────────────────────────────────────────────────────────────
let scene, camera, renderer, raycaster;
let trussGroup, gridHelper, labelsGroup, forcesGroup;
let isDragging = false, prevMouse = {x:0, y:0};
let mouseButton = -1;
let showGrid = true, showLabels = true, showForces = true, animMode = false;
let animT = 0;
let currentType = 'pratt';

// ─── INIT THREE.JS ───────────────────────────────────────────────────────────
function initThree() {
  const canvas = document.getElementById('canvas');
  renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0a0c0f);
  scene.fog = new THREE.FogExp2(0x0a0c0f, 0.008);

  camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
  camera.position.set(30, 20, 30);
  camera.lookAt(0, 0, 0);

  // Lights
  const amb = new THREE.AmbientLight(0x223344, 1.2);
  scene.add(amb);
  const dir = new THREE.DirectionalLight(0x00e5ff, 0.8);
  dir.position.set(20, 40, 20);
  scene.add(dir);
  const dir2 = new THREE.DirectionalLight(0xff6b35, 0.4);
  dir2.position.set(-20, 10, -20);
  scene.add(dir2);
  const pt = new THREE.PointLight(0x7fff6e, 0.5, 80);
  pt.position.set(0, 20, 0);
  scene.add(pt);

  // Grid
  gridHelper = new THREE.GridHelper(80, 40, 0x1e2832, 0x141a20);
  scene.add(gridHelper);

  trussGroup = new THREE.Group();
  scene.add(trussGroup);

  labelsGroup = new THREE.Group();
  scene.add(labelsGroup);

  forcesGroup = new THREE.Group();
  scene.add(forcesGroup);

  raycaster = new THREE.Raycaster();

  // Events
  canvas.addEventListener('mousedown', e => { isDragging = true; mouseButton = e.button; prevMouse = {x:e.clientX, y:e.clientY}; });
  window.addEventListener('mouseup', () => { isDragging = false; mouseButton = -1; });
  window.addEventListener('mousemove', onMouseMove);
  canvas.addEventListener('wheel', onWheel, {passive:true});
  window.addEventListener('resize', onResize);

  onResize();
  rebuild();
  animate();
}

function onResize() {
  const vp = document.querySelector('.viewport');
  const w = vp.clientWidth, h = vp.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}

function onMouseMove(e) {
  if (!isDragging) return;
  const dx = e.clientX - prevMouse.x;
  const dy = e.clientY - prevMouse.y;
  prevMouse = {x:e.clientX, y:e.clientY};

  if (mouseButton === 0) {
    // Orbit
    const spherical = new THREE.Spherical().setFromVector3(camera.position);
    spherical.theta -= dx * 0.01;
    spherical.phi -= dy * 0.01;
    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
    camera.position.setFromSpherical(spherical);
    camera.lookAt(0, 0, 0);
  } else if (mouseButton === 2 || mouseButton === 1) {
    // Pan
    const panSpeed = 0.05;
    const right = new THREE.Vector3().crossVectors(camera.getWorldDirection(new THREE.Vector3()), camera.up).normalize();
    camera.position.addScaledVector(right, -dx * panSpeed);
    camera.position.y += dy * panSpeed;
    camera.lookAt(0, 0, 0);
  }
}

function onWheel(e) {
  const factor = e.deltaY > 0 ? 1.1 : 0.9;
  camera.position.multiplyScalar(factor);
}

// ─── UTILITIES ───────────────────────────────────────────────────────────────
function P(x,y,z=0) { return {x,y,z}; }

function makeCylinder(p1, p2, radius, color, opacity=1) {
  const dir = new THREE.Vector3(p2.x-p1.x, p2.y-p1.y, p2.z-p1.z);
  const len = dir.length();
  if (len < 0.001) return null;
  const geo = new THREE.CylinderGeometry(radius, radius, len, 8, 1);
  const mat = new THREE.MeshPhongMaterial({
    color, transparent: opacity < 1, opacity,
    shininess: 80, emissive: new THREE.Color(color).multiplyScalar(0.1)
  });
  const mesh = new THREE.Mesh(geo, mat);
  const mid = new THREE.Vector3((p1.x+p2.x)/2,(p1.y+p2.y)/2,(p1.z+p2.z)/2);
  mesh.position.copy(mid);
  const axis = new THREE.Vector3(0,1,0);
  mesh.quaternion.setFromUnitVectors(axis, dir.normalize());
  return mesh;
}

function makeSphere(pos, radius, color) {
  const geo = new THREE.SphereGeometry(radius, 12, 12);
  const mat = new THREE.MeshPhongMaterial({
    color, shininess:100,
    emissive: new THREE.Color(color).multiplyScalar(0.3)
  });
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(pos.x, pos.y, pos.z);
  return mesh;
}

function makeArrow(pos, dir, length, color) {
  const g = new THREE.Group();
  const shaft = makeCylinder(
    {x:pos.x, y:pos.y, z:pos.z},
    {x:pos.x+dir.x*length*0.7, y:pos.y+dir.y*length*0.7, z:pos.z+dir.z*length*0.7},
    0.15, color
  );
  if (shaft) g.add(shaft);
  const headGeo = new THREE.ConeGeometry(0.35, length*0.3, 8);
  const headMat = new THREE.MeshPhongMaterial({color, emissive:new THREE.Color(color).multiplyScalar(0.4)});
  const head = new THREE.Mesh(headGeo, headMat);
  const tipPos = {x:pos.x+dir.x*length, y:pos.y+dir.y*length, z:pos.z+dir.z*length};
  head.position.set(
    (pos.x+dir.x*length*0.85),
    (pos.y+dir.y*length*0.85),
    (pos.z+dir.z*length*0.85)
  );
  const axis = new THREE.Vector3(0,1,0);
  head.quaternion.setFromUnitVectors(axis, new THREE.Vector3(dir.x,dir.y,dir.z).normalize());
  g.add(head);
  return g;
}

// ─── TRUSS BUILDERS ──────────────────────────────────────────────────────────
function buildNodes(type) {
  const span = parseFloat(document.getElementById('span').value);
  const H = parseFloat(document.getElementById('height').value) * parseFloat(document.getElementById('depth').value);
  const n = parseInt(document.getElementById('panels').value);
  const W = parseFloat(document.getElementById('width').value);
  const sag = parseFloat(document.getElementById('sag').value);
  const dx = span / n;

  let bottom = [], top = [];

  for (let i = 0; i <= n; i++) {
    const x = i * dx - span/2;
    // arch sag applied to bottom chord
    const archY = sag * 4 * (i/n) * (1 - i/n);
    bottom.push(P(x, archY, 0));

    let ty = H + archY;
    // arch type: top chord follows arch too
    if (type === 'arch') ty = H * Math.sin(Math.PI * i/n) + archY + 0.5;
    top.push(P(x, ty, 0));
  }

  // 3D width — duplicate for both sides
  if (W > 0) {
    const bot2 = bottom.map(p => P(p.x, p.y, W));
    const top2 = top.map(p => P(p.x, p.y, W));
    return { bottom, top, bottom2: bot2, top2: top2, n, span, dx, H, W };
  }
  return { bottom, top, bottom2: null, top2: null, n, span, dx, H, W };
}

function buildMembers(type, nodes) {
  const { bottom, top, bottom2, top2, n, W } = nodes;
  let members = []; // {a, b, kind}

  const bi = i => ({ arr: bottom, i });
  const ti = i => ({ arr: top, i });
  const getP = ref => ref.arr[ref.i];

  // Bottom chord
  for (let i = 0; i < n; i++) {
    members.push({ a: bottom[i], b: bottom[i+1], kind: 'chord-bottom' });
  }
  // Top chord
  for (let i = 0; i < n; i++) {
    members.push({ a: top[i], b: top[i+1], kind: 'chord-top' });
  }
  // Verticals & diagonals by type
  for (let i = 0; i <= n; i++) {
    members.push({ a: bottom[i], b: top[i], kind: 'vertical' });
  }

  if (type === 'pratt') {
    for (let i = 0; i < n; i++) {
      if (i < n/2) members.push({ a: bottom[i], b: top[i+1], kind: 'diagonal' });
      else         members.push({ a: bottom[i+1], b: top[i], kind: 'diagonal' });
    }
  } else if (type === 'howe') {
    for (let i = 0; i < n; i++) {
      if (i < n/2) members.push({ a: bottom[i+1], b: top[i], kind: 'diagonal' });
      else         members.push({ a: bottom[i], b: top[i+1], kind: 'diagonal' });
    }
  } else if (type === 'warren') {
    for (let i = 0; i < n; i++) {
      if (i % 2 === 0) members.push({ a: bottom[i], b: top[i+1], kind: 'diagonal' });
      else             members.push({ a: bottom[i+1], b: top[i], kind: 'diagonal' });
    }
  } else if (type === 'k-truss') {
    // Add midpoints on verticals
    for (let i = 1; i < n; i++) {
      const mid = P((bottom[i].x+top[i].x)/2, (bottom[i].y+top[i].y)/2, 0);
      members.push({ a: bottom[i-1], b: mid, kind: 'diagonal' });
      members.push({ a: top[i-1], b: mid, kind: 'diagonal' });
      members.push({ a: bottom[i+1] || bottom[i], b: mid, kind: 'diagonal' });
    }
  } else if (type === 'vierendeel') {
    // No diagonals — just verticals + chords (rigid frames)
    // no extra diagonals
  } else if (type === 'arch') {
    for (let i = 0; i < n; i++) {
      if (i % 2 === 0) members.push({ a: bottom[i], b: top[i+1], kind: 'diagonal' });
      else             members.push({ a: bottom[i+1], b: top[i], kind: 'diagonal' });
    }
  }

  // 3D cross-members if W > 0
  if (bottom2 && W > 0) {
    for (let i = 0; i <= n; i++) {
      members.push({ a: bottom[i], b: bottom2[i], kind: 'cross' });
      members.push({ a: top[i], b: top2[i], kind: 'cross' });
    }
    // Back face chords
    for (let i = 0; i < n; i++) {
      members.push({ a: bottom2[i], b: bottom2[i+1], kind: 'chord-bottom' });
      members.push({ a: top2[i], b: top2[i+1], kind: 'chord-top' });
    }
    // Back face verticals
    for (let i = 0; i <= n; i++) {
      members.push({ a: bottom2[i], b: top2[i], kind: 'vertical' });
    }
    // Back diagonals
    if (type === 'pratt') {
      for (let i = 0; i < n; i++) {
        if (i < n/2) members.push({ a: bottom2[i], b: top2[i+1], kind: 'diagonal' });
        else         members.push({ a: bottom2[i+1], b: top2[i], kind: 'diagonal' });
      }
    } else if (type === 'warren' || type === 'arch') {
      for (let i = 0; i < n; i++) {
        if (i % 2 === 0) members.push({ a: bottom2[i], b: top2[i+1], kind: 'diagonal' });
        else             members.push({ a: bottom2[i+1], b: top2[i], kind: 'diagonal' });
      }
    }
    // Cross-bracing between faces
    for (let i = 0; i < n; i++) {
      members.push({ a: bottom[i], b: bottom2[i+1], kind: 'cross' });
    }
  }

  return members;
}

// ─── SIMPLE FORCE ESTIMATION ─────────────────────────────────────────────────
function estimateForces(members, nodes) {
  const span = parseFloat(document.getElementById('span').value);
  const udl = parseFloat(document.getElementById('udl').value);
  const pl = parseFloat(document.getElementById('pl').value);
  const sw = parseFloat(document.getElementById('sw').value);
  const ploc = parseInt(document.getElementById('ploc').value);
  const n = nodes.n;
  const H = parseFloat(document.getElementById('height').value) * parseFloat(document.getElementById('depth').value);

  const totalW = (udl + sw) * span + pl;
  const R = totalW / 2;

  // Pratt-like: bottom chord tension ~M/H, top chord compression ~M/H
  // Approximate member forces
  return members.map((m, idx) => {
    const len = Math.sqrt(
      (m.b.x-m.a.x)**2+(m.b.y-m.a.y)**2+(m.b.z-m.a.z)**2
    );
    let F = 0;
    if (m.kind === 'chord-bottom') {
      // Max moment at mid: R*span/4
      const xMid = (m.a.x + m.b.x) / 2;
      const distFromEnd = xMid + span/2;
      const M = R * distFromEnd - (udl+sw)/2 * distFromEnd**2;
      F = M / Math.max(H, 0.1) * 0.9;  // tension
    } else if (m.kind === 'chord-top') {
      const xMid = (m.a.x + m.b.x) / 2;
      const distFromEnd = xMid + span/2;
      const M = R * distFromEnd - (udl+sw)/2 * distFromEnd**2;
      F = -M / Math.max(H, 0.1) * 0.9; // compression
    } else if (m.kind === 'vertical') {
      const x = m.a.x;
      const distFromEnd = x + span/2;
      const panelLoad = (udl + sw) * (span / n);
      F = panelLoad * (1 - 2*distFromEnd/span) * 0.5;
    } else if (m.kind === 'diagonal') {
      const xMid = (m.a.x + m.b.x) / 2;
      const V = R - (udl+sw)*(xMid+span/2);
      const angle = Math.atan2(Math.abs(m.b.y - m.a.y), Math.abs(m.b.x - m.a.x));
      F = -V / Math.sin(angle) * 0.5;
    } else if (m.kind === 'cross') {
      F = (udl+sw) * span / n * 0.2;
    }
    // Point load contribution
    const plocX = -span/2 + ploc * (span/n);
    if (m.kind === 'chord-bottom' || m.kind === 'chord-top') {
      const xm = (m.a.x + m.b.x) / 2;
      const sign = m.kind === 'chord-top' ? -1 : 1;
      F += sign * pl * Math.abs(plocX - xm) / (span * H + 0.01) * span * 0.4;
    }
    return { ...m, force: F, len };
  });
}

// ─── MAIN BUILD ──────────────────────────────────────────────────────────────
function rebuild() {
  // Clear
  while (trussGroup.children.length) trussGroup.remove(trussGroup.children[0]);
  while (labelsGroup.children.length) labelsGroup.remove(labelsGroup.children[0]);
  while (forcesGroup.children.length) forcesGroup.remove(forcesGroup.children[0]);

  const nodes = buildNodes(currentType);
  const rawMembers = buildMembers(currentType, nodes);
  const members = estimateForces(rawMembers, nodes);

  const memberR = parseFloat(document.getElementById('memberR').value) / 1000 * 2;
  const colorScheme = document.getElementById('colorScheme').value;
  const span = nodes.span;
  const n = nodes.n;
  const W = nodes.W;
  const udl = parseFloat(document.getElementById('udl').value);
  const sw = parseFloat(document.getElementById('sw').value);
  const pl = parseFloat(document.getElementById('pl').value);

  const maxF = Math.max(...members.map(m => Math.abs(m.force)), 1);

  // Draw members
  members.forEach((m, i) => {
    let color;
    if (colorScheme === 'stress') {
      const t = m.force / maxF; // -1 compression, +1 tension
      if (t > 0) color = new THREE.Color().setHSL(0, 0.9, 0.4 + t*0.3).getHex();       // red=tension
      else       color = new THREE.Color().setHSL(0.55, 0.9, 0.4 + (-t)*0.3).getHex(); // cyan=compression
    } else if (colorScheme === 'type') {
      const typeColors = {
        'chord-top': 0x00e5ff, 'chord-bottom': 0xff6b35,
        'diagonal': 0xffcc00, 'vertical': 0x7fff6e, 'cross': 0xaa88ff
      };
      color = typeColors[m.kind] || 0xffffff;
    } else if (colorScheme === 'length') {
      const maxL = Math.max(...members.map(x=>x.len), 1);
      color = new THREE.Color().setHSL(m.len/maxL * 0.7, 0.8, 0.5).getHex();
    } else {
      color = 0x334455;
    }

    const r = m.kind === 'cross' ? memberR * 0.5 : memberR;
    const cyl = makeCylinder(m.a, m.b, r, color);
    if (cyl) trussGroup.add(cyl);
  });

  // Collect unique nodes
  const allNodes = [];
  members.forEach(m => {
    if (!allNodes.find(p => p.x===m.a.x && p.y===m.a.y && p.z===m.a.z)) allNodes.push(m.a);
    if (!allNodes.find(p => p.x===m.b.x && p.y===m.b.y && p.z===m.b.z)) allNodes.push(m.b);
  });

  // Draw nodes
  allNodes.forEach(p => {
    const isSupport = (Math.abs(p.x + span/2) < 0.01 || Math.abs(p.x - span/2) < 0.01) && p.y < 0.5;
    const color = isSupport ? 0x7fff6e : 0x00e5ff;
    const sph = makeSphere(p, memberR * 1.5, color);
    trussGroup.add(sph);

    // Support symbols
    if (isSupport && showForces) {
      const R = (udl+sw)*span/2 + pl/2;
      const arr = makeArrow(
        {x:p.x, y:p.y-0.5, z:p.z},
        {x:0, y:1, z:0}, 2.5, 0x7fff6e
      );
      forcesGroup.add(arr);
    }
  });

  // Draw load arrows
  if (showForces && (udl + sw > 0 || pl > 0)) {
    const ploc = parseInt(document.getElementById('ploc').value);
    const dx = span / n;
    nodes.bottom.forEach((p, i) => {
      const nodeLoad = (udl + sw) * dx + (i === ploc ? pl : 0);
      if (nodeLoad > 0) {
        const scale = Math.min(3, 0.8 + nodeLoad / 30);
        const arr = makeArrow(
          {x:p.x, y:nodes.top[i].y + 2, z:p.z},
          {x:0, y:-1, z:0}, scale, 0xff4444
        );
        forcesGroup.add(arr);
      }
    });
  }

  // Update stats
  const tension = members.filter(m=>m.force>0).reduce((a,m)=>Math.max(a,m.force),0);
  const compress = members.filter(m=>m.force<0).reduce((a,m)=>Math.min(a,m.force),0);
  const totalLoad = (udl+sw)*span + pl;
  const memberCount = members.length;
  const nodeCount = allNodes.length;

  document.getElementById('stat-nodes').textContent = nodeCount;
  document.getElementById('stat-members').textContent = memberCount;
  document.getElementById('stat-tension').textContent = tension.toFixed(1) + ' kN';
  document.getElementById('stat-compress').textContent = Math.abs(compress).toFixed(1) + ' kN';
  document.getElementById('stat-reactions').textContent = totalLoad.toFixed(1) + ' kN';
  document.getElementById('stat-slender').textContent = (span / Math.max(nodes.H, 0.1)).toFixed(1);

  document.getElementById('hdr-nodes').textContent = nodeCount + ' nodes';
  document.getElementById('hdr-members').textContent = memberCount + ' members';

  const m = memberCount, nd = nodeCount;
  const det = m - 2*nd + 3;
  document.getElementById('hdr-dof').textContent = det === 0 ? 'Isostatic' : det > 0 ? 'Hyperstatic +'+det : 'Mechanism!';
  document.getElementById('fi-stab').textContent = det >= 0 ? 'Stable' : '⚠ Mechanism';
  document.getElementById('fi-load').textContent = totalLoad.toFixed(1) + ' kN';
  document.getElementById('fi-defl').textContent = '~L/' + Math.round(200 + tension/2);
}

// ─── CONTROLS ────────────────────────────────────────────────────────────────
function syncVal(id, displayId, suffix) {
  document.getElementById(displayId).textContent = document.getElementById(id).value + suffix;
}

function setType(type) {
  currentType = type;
  document.querySelectorAll('.type-btn').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');
  rebuild();
}

function resetCamera() {
  camera.position.set(30, 20, 30);
  camera.lookAt(0, 0, 0);
}

function toggleGrid() {
  showGrid = !showGrid;
  gridHelper.visible = showGrid;
  document.getElementById('btn-grid').classList.toggle('on', showGrid);
}

function toggleLabels() {
  showLabels = !showLabels;
  labelsGroup.visible = showLabels;
  document.getElementById('btn-labels').classList.toggle('on', showLabels);
}

function toggleForces() {
  showForces = !showForces;
  forcesGroup.visible = showForces;
  document.getElementById('btn-forces').classList.toggle('on', showForces);
  rebuild();
}

function toggleAnim() {
  animMode = !animMode;
  document.getElementById('btn-anim').classList.toggle('on', animMode);
}

function randomize() {
  const types = ['pratt','howe','warren','k-truss','vierendeel','arch'];
  currentType = types[Math.floor(Math.random()*types.length)];
  document.querySelectorAll('.type-btn').forEach((b,i) => {
    b.classList.toggle('active', types[i] === currentType);
  });
  const rr = (id, mn, mx, step) => {
    const v = (Math.random()*(mx-mn)+mn);
    const snapped = Math.round(v/step)*step;
    document.getElementById(id).value = snapped;
    const dispId = 'v-' + id;
    const el = document.getElementById(dispId);
    if (el) el.textContent = snapped;
  };
  rr('span', 12, 48, 2);
  rr('height', 2, 10, 0.5);
  rr('panels', 4, 12, 2);
  rr('width', 0, 8, 1);
  rr('udl', 0, 60, 5);
  rr('pl', 0, 300, 10);
  rr('sag', 0, 6, 0.5);
  rebuild();
}

function exportData() {
  const nodes = buildNodes(currentType);
  const members = buildMembers(currentType, nodes);
  const data = {
    type: currentType,
    span: parseFloat(document.getElementById('span').value),
    height: parseFloat(document.getElementById('height').value),
    panels: parseInt(document.getElementById('panels').value),
    udl: parseFloat(document.getElementById('udl').value),
    memberCount: members.length,
    nodeCount: (nodes.bottom.length + nodes.top.length),
    generated: new Date().toISOString()
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'truss-model.json';
  a.click();
}

// ─── ANIMATION LOOP ──────────────────────────────────────────────────────────
function animate() {
  requestAnimationFrame(animate);
  if (animMode) {
    animT += 0.01;
    camera.position.x = Math.cos(animT) * 40;
    camera.position.z = Math.sin(animT) * 40;
    camera.lookAt(0, 0, 0);
  }
  renderer.render(scene, camera);
}

// ─── START ───────────────────────────────────────────────────────────────────
window.addEventListener('load', initThree);
window.addEventListener('contextmenu', e => e.preventDefault());
</script>
</body>
</html>